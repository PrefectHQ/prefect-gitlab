{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-gitlab Welcome! prefect-gitlab is a Prefect collection for working with GitLab repositories. Getting Started Python setup Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. This collection is designed to work with Prefect 2.3.0 or higher. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-gitlab with pip : pip install prefect-gitlab Then, register to view the storage block on Prefect Cloud: prefect block register -m prefect_gitlab Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI . Creating a GitLab storage block In Python from prefect_gitlab import GitLabRepository # public GitLab repository public_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" ) public_gitlab_block . save () # specific branch or tag of a GitLab repository branch_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , reference = \"branch-or-tag-name\" repository = \"https://gitlab.com/testing/my-repository.git\" ) branch_gitlab_block . save () # private GitLab repository private_gitlab_block = GitLabRepository ( name = \"my-private-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" , access_token = \"YOUR_GITLAB_PERSONAL_ACCESS_TOKEN\" ) private_gitlab_block . save () In the UI Click on the Blocks menu, then click the + button in the page header to open the block catalog: Then, find the GitLab block and click the Add button: Finally, enter your repository information in the form and click Create : Resources If you encounter any bugs while using prefect-gitlab , feel free to open an issue in the prefect-gitlab repository. If you have any questions or issues while using prefect-gitlab , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to \u2b50\ufe0f or watch prefect-gitlab for updates too! Development If you'd like to install a version of prefect-gitlab for development, clone the repository and perform an editable install with pip : git clone https://github.com/prefecthq/prefect-gitlab.git cd prefect-gitlab/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Home"},{"location":"#prefect-gitlab","text":"","title":"prefect-gitlab"},{"location":"#welcome","text":"prefect-gitlab is a Prefect collection for working with GitLab repositories.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. This collection is designed to work with Prefect 2.3.0 or higher. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-gitlab with pip : pip install prefect-gitlab Then, register to view the storage block on Prefect Cloud: prefect block register -m prefect_gitlab Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI .","title":"Installation"},{"location":"#creating-a-gitlab-storage-block","text":"","title":"Creating a GitLab storage block"},{"location":"#in-python","text":"from prefect_gitlab import GitLabRepository # public GitLab repository public_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" ) public_gitlab_block . save () # specific branch or tag of a GitLab repository branch_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , reference = \"branch-or-tag-name\" repository = \"https://gitlab.com/testing/my-repository.git\" ) branch_gitlab_block . save () # private GitLab repository private_gitlab_block = GitLabRepository ( name = \"my-private-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" , access_token = \"YOUR_GITLAB_PERSONAL_ACCESS_TOKEN\" ) private_gitlab_block . save ()","title":"In Python"},{"location":"#in-the-ui","text":"Click on the Blocks menu, then click the + button in the page header to open the block catalog: Then, find the GitLab block and click the Add button: Finally, enter your repository information in the form and click Create :","title":"In the UI"},{"location":"#resources","text":"If you encounter any bugs while using prefect-gitlab , feel free to open an issue in the prefect-gitlab repository. If you have any questions or issues while using prefect-gitlab , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to \u2b50\ufe0f or watch prefect-gitlab for updates too!","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-gitlab for development, clone the repository and perform an editable install with pip : git clone https://github.com/prefecthq/prefect-gitlab.git cd prefect-gitlab/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Development"},{"location":"credentials/","text":"prefect_gitlab.credentials Module used to enable authenticated interactions with GitLab Classes GitLabCredentials Bases: Block Store a GitLab personal access token to interact with private GitLab repositories. Attributes: Name Type Description token SecretStr The token to authenticate into GitLab. Examples: Load stored GitLab credentials: from prefect_gitlab import GitLabCredentials gitlab_credentials_block = GitLabCredentials . load ( \"BLOCK_NAME\" ) Source code in prefect_gitlab/credentials.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class GitLabCredentials ( Block ): \"\"\" Store a GitLab personal access token to interact with private GitLab repositories. Attributes: token: The token to authenticate into GitLab. Examples: Load stored GitLab credentials: ```python from prefect_gitlab import GitLabCredentials gitlab_credentials_block = GitLabCredentials.load(\"BLOCK_NAME\") ``` \"\"\" _block_type_name = \"GitLab Credentials\" _logo_url = HttpUrl ( url = \"https://images.ctfassets.net/gm98wzqotmnx/55edIimT4g9gbjhkh5a3Sp/dfdb9391d8f45c2e93e72e3a4d350771/gitlab-logo-500.png?h=250\" , # noqa scheme = \"https\" , ) token : SecretStr = Field ( name = \"Personal Access Token\" , default = None , description = \"A GitLab Personal Access Token with repo scope.\" , )","title":"Credentials"},{"location":"credentials/#prefect_gitlab.credentials","text":"Module used to enable authenticated interactions with GitLab","title":"credentials"},{"location":"credentials/#prefect_gitlab.credentials-classes","text":"","title":"Classes"},{"location":"credentials/#prefect_gitlab.credentials.GitLabCredentials","text":"Bases: Block Store a GitLab personal access token to interact with private GitLab repositories. Attributes: Name Type Description token SecretStr The token to authenticate into GitLab. Examples: Load stored GitLab credentials: from prefect_gitlab import GitLabCredentials gitlab_credentials_block = GitLabCredentials . load ( \"BLOCK_NAME\" ) Source code in prefect_gitlab/credentials.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class GitLabCredentials ( Block ): \"\"\" Store a GitLab personal access token to interact with private GitLab repositories. Attributes: token: The token to authenticate into GitLab. Examples: Load stored GitLab credentials: ```python from prefect_gitlab import GitLabCredentials gitlab_credentials_block = GitLabCredentials.load(\"BLOCK_NAME\") ``` \"\"\" _block_type_name = \"GitLab Credentials\" _logo_url = HttpUrl ( url = \"https://images.ctfassets.net/gm98wzqotmnx/55edIimT4g9gbjhkh5a3Sp/dfdb9391d8f45c2e93e72e3a4d350771/gitlab-logo-500.png?h=250\" , # noqa scheme = \"https\" , ) token : SecretStr = Field ( name = \"Personal Access Token\" , default = None , description = \"A GitLab Personal Access Token with repo scope.\" , )","title":"GitLabCredentials"},{"location":"repositories/","text":"prefect_gitlab.repositories Integrations with GitLab. The GitLab class in this collection is a storage block that lets Prefect agents pull Prefect flow code from GitLab repositories. The GitLab block is ideally configured via the Prefect UI, but can also be used in Python as the following examples demonstrate. Examples: from prefect_gitlab.repositories import GitLabRepository # public GitLab repository public_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" ) public_gitlab_block . save () # specific branch or tag of a GitLab repository branch_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , reference = \"branch-or-tag-name\" repository = \"https://gitlab.com/testing/my-repository.git\" ) branch_gitlab_block . save () # private GitLab repository private_gitlab_block = GitLabRepository ( name = \"my-private-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" , access_token = \"YOUR_GITLAB_PERSONAL_ACCESS_TOKEN\" ) private_gitlab_block . save () Classes GitLabRepository Bases: ReadableDeploymentStorage Interact with files stored in GitLab repositories. An accessible installation of git is required for this block to function properly. Source code in prefect_gitlab/repositories.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class GitLabRepository ( ReadableDeploymentStorage ): \"\"\" Interact with files stored in GitLab repositories. An accessible installation of git is required for this block to function properly. \"\"\" _block_type_name = \"GitLab Repository\" _logo_url = HttpUrl ( url = \"https://images.ctfassets.net/gm98wzqotmnx/55edIimT4g9gbjhkh5a3Sp/dfdb9391d8f45c2e93e72e3a4d350771/gitlab-logo-500.png?h=250\" , # noqa scheme = \"https\" , ) _description = \"Interact with files stored in GitLab repositories.\" repository : str = Field ( default =... , description = ( \"The URL of a GitLab repository to read from, in either HTTPS or SSH format.\" # noqa ), ) reference : Optional [ str ] = Field ( default = None , description = \"An optional reference to pin to; can be a branch name or tag.\" , ) credentials : Optional [ GitLabCredentials ] = Field ( default = None , description = \"An optional GitLab Credentials block for authenticating with \" \"private GitLab repos.\" , ) @validator ( \"credentials\" ) def _ensure_credentials_go_with_https ( cls , v : str , values : dict ) -> str : \"\"\"Ensure that credentials are not provided with 'SSH' formatted GitLub URLs. Note: validates `access_token` specifically so that it only fires when private repositories are used. \"\"\" if v is not None : if urllib . parse . urlparse ( values [ \"repository\" ]) . scheme != \"https\" : raise InvalidRepositoryURLError ( ( \"Credentials can only be used with GitLab repositories \" \"using the 'HTTPS' format. You must either remove the \" \"credential if you wish to use the 'SSH' format and are not \" \"using a private repository, or you must change the repository \" \"URL to the 'HTTPS' format.\" ) ) return v def _create_repo_url ( self ) -> str : \"\"\"Format the URL provided to the `git clone` command. For private repos: https://<oauth-key>@gitlab.com/<username>/<repo>.git All other repos should be the same as `self.repository`. \"\"\" url_components = urllib . parse . urlparse ( self . repository ) if url_components . scheme == \"https\" and self . credentials is not None : token = self . credentials . token . get_secret_value () updated_components = url_components . _replace ( netloc = f \"oauth2: { token } @ { url_components . netloc } \" ) full_url = urllib . parse . urlunparse ( updated_components ) else : full_url = self . repository return full_url @staticmethod def _get_paths ( dst_dir : Union [ str , None ], src_dir : str , sub_directory : Optional [ str ] ) -> Tuple [ str , str ]: \"\"\"Returns the fully formed paths for GitLabRepository contents in the form (content_source, content_destination). \"\"\" if dst_dir is None : content_destination = Path ( \".\" ) . absolute () else : content_destination = Path ( dst_dir ) content_source = Path ( src_dir ) if sub_directory : content_destination = content_destination . joinpath ( sub_directory ) content_source = content_source . joinpath ( sub_directory ) return str ( content_source ), str ( content_destination ) @sync_compatible async def get_directory ( self , from_path : Optional [ str ] = None , local_path : Optional [ str ] = None ) -> None : \"\"\" Clones a GitLab project specified in `from_path` to the provided `local_path`; defaults to cloning the repository reference configured on the Block to the present working directory. Args: from_path: If provided, interpreted as a subdirectory of the underlying repository that will be copied to the provided local path. local_path: A local path to clone to; defaults to present working directory. \"\"\" # CONSTRUCT COMMAND cmd = [ \"git\" , \"clone\" , self . _create_repo_url ()] if self . reference : cmd += [ \"-b\" , self . reference ] # Limit git history cmd += [ \"--depth\" , \"1\" ] # Clone to a temporary directory and move the subdirectory over with TemporaryDirectory ( suffix = \"prefect\" ) as tmp_dir : cmd . append ( tmp_dir ) err_stream = io . StringIO () out_stream = io . StringIO () process = await run_process ( cmd , stream_output = ( out_stream , err_stream )) if process . returncode != 0 : err_stream . seek ( 0 ) raise OSError ( f \"Failed to pull from remote: \\n { err_stream . read () } \" ) content_source , content_destination = self . _get_paths ( dst_dir = local_path , src_dir = tmp_dir , sub_directory = from_path ) copy_tree ( src = content_source , dst = content_destination ) Functions get_directory async Clones a GitLab project specified in from_path to the provided local_path ; defaults to cloning the repository reference configured on the Block to the present working directory. Parameters: Name Type Description Default from_path Optional [ str ] If provided, interpreted as a subdirectory of the underlying repository that will be copied to the provided local path. None local_path Optional [ str ] A local path to clone to; defaults to present working directory. None Source code in prefect_gitlab/repositories.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @sync_compatible async def get_directory ( self , from_path : Optional [ str ] = None , local_path : Optional [ str ] = None ) -> None : \"\"\" Clones a GitLab project specified in `from_path` to the provided `local_path`; defaults to cloning the repository reference configured on the Block to the present working directory. Args: from_path: If provided, interpreted as a subdirectory of the underlying repository that will be copied to the provided local path. local_path: A local path to clone to; defaults to present working directory. \"\"\" # CONSTRUCT COMMAND cmd = [ \"git\" , \"clone\" , self . _create_repo_url ()] if self . reference : cmd += [ \"-b\" , self . reference ] # Limit git history cmd += [ \"--depth\" , \"1\" ] # Clone to a temporary directory and move the subdirectory over with TemporaryDirectory ( suffix = \"prefect\" ) as tmp_dir : cmd . append ( tmp_dir ) err_stream = io . StringIO () out_stream = io . StringIO () process = await run_process ( cmd , stream_output = ( out_stream , err_stream )) if process . returncode != 0 : err_stream . seek ( 0 ) raise OSError ( f \"Failed to pull from remote: \\n { err_stream . read () } \" ) content_source , content_destination = self . _get_paths ( dst_dir = local_path , src_dir = tmp_dir , sub_directory = from_path ) copy_tree ( src = content_source , dst = content_destination )","title":"Repositories"},{"location":"repositories/#prefect_gitlab.repositories","text":"Integrations with GitLab. The GitLab class in this collection is a storage block that lets Prefect agents pull Prefect flow code from GitLab repositories. The GitLab block is ideally configured via the Prefect UI, but can also be used in Python as the following examples demonstrate. Examples: from prefect_gitlab.repositories import GitLabRepository # public GitLab repository public_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" ) public_gitlab_block . save () # specific branch or tag of a GitLab repository branch_gitlab_block = GitLabRepository ( name = \"my-gitlab-block\" , reference = \"branch-or-tag-name\" repository = \"https://gitlab.com/testing/my-repository.git\" ) branch_gitlab_block . save () # private GitLab repository private_gitlab_block = GitLabRepository ( name = \"my-private-gitlab-block\" , repository = \"https://gitlab.com/testing/my-repository.git\" , access_token = \"YOUR_GITLAB_PERSONAL_ACCESS_TOKEN\" ) private_gitlab_block . save ()","title":"repositories"},{"location":"repositories/#prefect_gitlab.repositories-classes","text":"","title":"Classes"},{"location":"repositories/#prefect_gitlab.repositories.GitLabRepository","text":"Bases: ReadableDeploymentStorage Interact with files stored in GitLab repositories. An accessible installation of git is required for this block to function properly. Source code in prefect_gitlab/repositories.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class GitLabRepository ( ReadableDeploymentStorage ): \"\"\" Interact with files stored in GitLab repositories. An accessible installation of git is required for this block to function properly. \"\"\" _block_type_name = \"GitLab Repository\" _logo_url = HttpUrl ( url = \"https://images.ctfassets.net/gm98wzqotmnx/55edIimT4g9gbjhkh5a3Sp/dfdb9391d8f45c2e93e72e3a4d350771/gitlab-logo-500.png?h=250\" , # noqa scheme = \"https\" , ) _description = \"Interact with files stored in GitLab repositories.\" repository : str = Field ( default =... , description = ( \"The URL of a GitLab repository to read from, in either HTTPS or SSH format.\" # noqa ), ) reference : Optional [ str ] = Field ( default = None , description = \"An optional reference to pin to; can be a branch name or tag.\" , ) credentials : Optional [ GitLabCredentials ] = Field ( default = None , description = \"An optional GitLab Credentials block for authenticating with \" \"private GitLab repos.\" , ) @validator ( \"credentials\" ) def _ensure_credentials_go_with_https ( cls , v : str , values : dict ) -> str : \"\"\"Ensure that credentials are not provided with 'SSH' formatted GitLub URLs. Note: validates `access_token` specifically so that it only fires when private repositories are used. \"\"\" if v is not None : if urllib . parse . urlparse ( values [ \"repository\" ]) . scheme != \"https\" : raise InvalidRepositoryURLError ( ( \"Credentials can only be used with GitLab repositories \" \"using the 'HTTPS' format. You must either remove the \" \"credential if you wish to use the 'SSH' format and are not \" \"using a private repository, or you must change the repository \" \"URL to the 'HTTPS' format.\" ) ) return v def _create_repo_url ( self ) -> str : \"\"\"Format the URL provided to the `git clone` command. For private repos: https://<oauth-key>@gitlab.com/<username>/<repo>.git All other repos should be the same as `self.repository`. \"\"\" url_components = urllib . parse . urlparse ( self . repository ) if url_components . scheme == \"https\" and self . credentials is not None : token = self . credentials . token . get_secret_value () updated_components = url_components . _replace ( netloc = f \"oauth2: { token } @ { url_components . netloc } \" ) full_url = urllib . parse . urlunparse ( updated_components ) else : full_url = self . repository return full_url @staticmethod def _get_paths ( dst_dir : Union [ str , None ], src_dir : str , sub_directory : Optional [ str ] ) -> Tuple [ str , str ]: \"\"\"Returns the fully formed paths for GitLabRepository contents in the form (content_source, content_destination). \"\"\" if dst_dir is None : content_destination = Path ( \".\" ) . absolute () else : content_destination = Path ( dst_dir ) content_source = Path ( src_dir ) if sub_directory : content_destination = content_destination . joinpath ( sub_directory ) content_source = content_source . joinpath ( sub_directory ) return str ( content_source ), str ( content_destination ) @sync_compatible async def get_directory ( self , from_path : Optional [ str ] = None , local_path : Optional [ str ] = None ) -> None : \"\"\" Clones a GitLab project specified in `from_path` to the provided `local_path`; defaults to cloning the repository reference configured on the Block to the present working directory. Args: from_path: If provided, interpreted as a subdirectory of the underlying repository that will be copied to the provided local path. local_path: A local path to clone to; defaults to present working directory. \"\"\" # CONSTRUCT COMMAND cmd = [ \"git\" , \"clone\" , self . _create_repo_url ()] if self . reference : cmd += [ \"-b\" , self . reference ] # Limit git history cmd += [ \"--depth\" , \"1\" ] # Clone to a temporary directory and move the subdirectory over with TemporaryDirectory ( suffix = \"prefect\" ) as tmp_dir : cmd . append ( tmp_dir ) err_stream = io . StringIO () out_stream = io . StringIO () process = await run_process ( cmd , stream_output = ( out_stream , err_stream )) if process . returncode != 0 : err_stream . seek ( 0 ) raise OSError ( f \"Failed to pull from remote: \\n { err_stream . read () } \" ) content_source , content_destination = self . _get_paths ( dst_dir = local_path , src_dir = tmp_dir , sub_directory = from_path ) copy_tree ( src = content_source , dst = content_destination )","title":"GitLabRepository"},{"location":"repositories/#prefect_gitlab.repositories.GitLabRepository-functions","text":"","title":"Functions"},{"location":"repositories/#prefect_gitlab.repositories.GitLabRepository.get_directory","text":"Clones a GitLab project specified in from_path to the provided local_path ; defaults to cloning the repository reference configured on the Block to the present working directory. Parameters: Name Type Description Default from_path Optional [ str ] If provided, interpreted as a subdirectory of the underlying repository that will be copied to the provided local path. None local_path Optional [ str ] A local path to clone to; defaults to present working directory. None Source code in prefect_gitlab/repositories.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @sync_compatible async def get_directory ( self , from_path : Optional [ str ] = None , local_path : Optional [ str ] = None ) -> None : \"\"\" Clones a GitLab project specified in `from_path` to the provided `local_path`; defaults to cloning the repository reference configured on the Block to the present working directory. Args: from_path: If provided, interpreted as a subdirectory of the underlying repository that will be copied to the provided local path. local_path: A local path to clone to; defaults to present working directory. \"\"\" # CONSTRUCT COMMAND cmd = [ \"git\" , \"clone\" , self . _create_repo_url ()] if self . reference : cmd += [ \"-b\" , self . reference ] # Limit git history cmd += [ \"--depth\" , \"1\" ] # Clone to a temporary directory and move the subdirectory over with TemporaryDirectory ( suffix = \"prefect\" ) as tmp_dir : cmd . append ( tmp_dir ) err_stream = io . StringIO () out_stream = io . StringIO () process = await run_process ( cmd , stream_output = ( out_stream , err_stream )) if process . returncode != 0 : err_stream . seek ( 0 ) raise OSError ( f \"Failed to pull from remote: \\n { err_stream . read () } \" ) content_source , content_destination = self . _get_paths ( dst_dir = local_path , src_dir = tmp_dir , sub_directory = from_path ) copy_tree ( src = content_source , dst = content_destination )","title":"get_directory()"}]}